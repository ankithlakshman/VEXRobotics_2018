#pragma config(Sensor, in5,    lift01Pot,      sensorPotentiometer)
#pragma config(Sensor, in7,    lift03Pot,      sensorPotentiometer)
#pragma config(Sensor, dgtl3,  lift03Encoder,  sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  lift01Encoder,  sensorQuadEncoder)
#pragma config(Motor,  port3,           lift01,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           lift03,        tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define PID_DRIVE_MAX       127
#define PID_DRIVE_MIN     (-127)

#define PID_INTEGRAL_LIMIT  50

int POSITION_REQUESTED;
int rightEncoder;
int leftEncoder;
int pot1;

float  pid_Kp = 0.0;//3.0
float  pid_Ki = 0.00;//0.04
float  pid_Kd = 0.0;

int rightliftdrive;
int leftliftdrive;

task RIGHT_PID(){

	float  pidSensorCurrentValue;

	float  pidError;
	float  pidLastError;
	float  pidIntegral;
	float  pidDerivative;

	// Initiate the variables
	pidLastError  = 0;
	pidIntegral   = 0;

	while( true )
	{
		// Read the sensor value and scale
		pidSensorCurrentValue = SensorValue(lift01Encoder);

		// calculate error
		pidError = (POSITION_REQUESTED - pidSensorCurrentValue);

		// integral - if Ki is not 0
		if( pid_Ki != 0 )
		{
			// If we are inside controlable window then integrate the error
			if( abs(pidError) < PID_INTEGRAL_LIMIT )
				pidIntegral = pidIntegral + pidError;
			else
				pidIntegral = 0;
		}
		else
			pidIntegral = 0;

		// calculate the derivative
		pidDerivative = pidError - pidLastError;
		pidLastError  = pidError;

		// calculate drive
		rightliftdrive = (pid_Kp * pidError) + (pid_Ki * pidIntegral) + (pid_Kd * pidDerivative);

		// limit drive
		if( rightliftdrive > PID_DRIVE_MAX )
			rightliftdrive = PID_DRIVE_MAX;
		if( rightliftdrive < PID_DRIVE_MIN )
			rightliftdrive = PID_DRIVE_MIN;

		// send to motor
		motor[lift01] = rightliftdrive;
		motor[lift03] = rightliftdrive;
		// Run at 50Hz
		wait1Msec( 25 );
	}

}

task LEFT_PID(){

	float  pidSensorCurrentValue;

	float  pidError;
	float  pidLastError;
	float  pidIntegral;
	float  pidDerivative;

	// Initiate the variables
	pidLastError  = 0;
	pidIntegral   = 0;

	while( true )
	{
		// Read the sensor value and scale
		pidSensorCurrentValue = SensorValue(lift03Encoder);

		// calculate error
		pidError = (POSITION_REQUESTED - pidSensorCurrentValue);

		// integral - if Ki is not 0
		if( pid_Ki != 0 )
		{
			// If we are inside controlable window then integrate the error
			if( abs(pidError) < PID_INTEGRAL_LIMIT )
				pidIntegral = pidIntegral + pidError;
			else
				pidIntegral = 0;
		}
		else
			pidIntegral = 0;

		// calculate the derivative
		pidDerivative = pidError - pidLastError;
		pidLastError  = pidError;

		// calculate drive
		leftliftdrive = (pid_Kp * pidError) + (pid_Ki * pidIntegral) + (pid_Kd * pidDerivative);

		// limit drive
		if( leftliftdrive > PID_DRIVE_MAX )
			leftliftdrive = PID_DRIVE_MAX;
		if( leftliftdrive < PID_DRIVE_MIN )
			leftliftdrive = PID_DRIVE_MIN;

		// send to motor
		motor[lift03] = leftliftdrive;
		// Run at 50Hz
		wait1Msec( 25 );
	}

}

task lifting(){

	int highlimit = 1400;
	int lowlimit = 0;

	int liftSpeed = 125;
	int brakeSpeed = 10;

	int positionIncrement = 10;
	int waitTime = 100;

	POSITION_REQUESTED = 0;

	while(true){
		if(vexRT[Btn6U] == 1){
			if(POSITION_REQUESTED < highlimit){
				POSITION_REQUESTED+=positionIncrement;
				wait1Msec(waitTime);
			}
			else{
				POSITION_REQUESTED=POSITION_REQUESTED;
			}
		}
		else if(vexRT[Btn6D] == 1){
			if(POSITION_REQUESTED > lowlimit){
				POSITION_REQUESTED-=positionIncrement;
				wait1Msec(waitTime);
			}
			else{
				POSITION_REQUESTED=POSITION_REQUESTED;
			}
		}
	}
}

task main(){

	startTask(RIGHT_PID);
	//startTask(LEFT_PID);
	startTask(lifting);

	while(true){
		rightEncoder = SensorValue(lift01Pot);
		leftEncoder = SensorValue(lift03Pot);
	}
}
